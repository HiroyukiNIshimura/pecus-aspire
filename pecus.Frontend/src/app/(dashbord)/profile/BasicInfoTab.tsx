"use client";

import { useState, useRef, useEffect } from "react";
import type { UserInfo } from "@/types/userInfo";
import { updateProfile, uploadAvatarFile, deleteAvatarFile } from "@/actions/profile";
import { useFormValidation } from "@/hooks/useFormValidation";
import { usernameSchema } from "@/schemas/profileSchemas";
import { z } from "zod";

interface BasicInfoTabProps {
  user: UserInfo;
  onUpdate: (updatedUser: UserInfo) => void;
  notify: {
    success: (message: string) => void;
    error: (message: string) => void;
    warning: (message: string) => void;
    info: (message: string) => void;
  };
  isLoading: boolean;
  setIsLoading: (loading: boolean) => void;
}

export default function BasicInfoTab({
  user,
  onUpdate,
  notify,
  isLoading,
  setIsLoading,
}: BasicInfoTabProps) {
  // フォームバリデーションスキーマの定義
  const basicInfoSchema = z.object({
    username: usernameSchema,
  });

  const [selectedAvatarType, setSelectedAvatarType] = useState<
    "Gravatar" | "UserAvatar" | "AutoGenerated"
  >(user.avatarType || "Gravatar");
  const [uploadedFileUrl, setUploadedFileUrl] = useState<string | null>(user.userAvatarPath || null);
  const [avatarPreviewUrl, setAvatarPreviewUrl] = useState<string | null>(null);
  const [avatarBlobUrl, setAvatarBlobUrl] = useState<string | null>(null);
  const [isDragging, setIsDragging] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);

  // Server Action を早期バインド（初期レンダリング時にエンドポイントを確立）
  const uploadActionRef = useRef(uploadAvatarFile);

  // フォームバリデーションフック
  const {
    formRef,
    isSubmitting,
    fieldErrors,
    handleSubmit,
    validateField,
    shouldShowError,
    getFieldError,
  } = useFormValidation({
    schema: basicInfoSchema,
    onSubmit: async (data) => {
      try {
        const result = await updateProfile({
          username: data.username !== user.username ? data.username : undefined,
          avatarType: selectedAvatarType,
          userAvatarPath: uploadedFileUrl || undefined,
          rowVersion: user.rowVersion!,
        });

        if (result.success) {
          // UserResponseからUserInfoに変換して更新
          const updatedUserInfo: UserInfo = {
            ...user,
            username: result.data.username,
            avatarType: result.data.avatarType,
            userAvatarPath: result.data.userAvatarPath,
            identityIconUrl: result.data.identityIconUrl,
            rowVersion: result.data.rowVersion,
          };
          onUpdate(updatedUserInfo);
          setUploadedFileUrl(result.data.userAvatarPath || null);
          setAvatarPreviewUrl(null);
          notify.success("基本情報が更新されました");
        } else {
          notify.error(result.message || "更新に失敗しました");
        }
      } catch (error) {
        console.error("Profile update error:", error);
        notify.error("予期しないエラーが発生しました");
      }
    },
  });

  // 既存のアバター画像の表示（/api/profile/avatar/dataurl エンドポイント経由）
  useEffect(() => {
    const loadExistingAvatar = async () => {
      // カスタム画像タイプが選択されていて、userAvatarPath があれば取得
      if (selectedAvatarType === "UserAvatar" && user.userAvatarPath && !avatarPreviewUrl) {
        try {
          const response = await fetch('/api/profile/avatar/dataurl');

          if (response.ok) {
            const result = await response.json();
            setAvatarBlobUrl(result.dataUrl);
          } else if (response.status === 404) {
            // アバターが設定されていない場合はクリア（自動生成画像を表示しない）
            console.info("Avatar not set");
            setAvatarBlobUrl(null);
          } else {
            console.error("Failed to load existing avatar:", response.statusText);
            // エラー時もクリア
            setAvatarBlobUrl(null);
          }
        } catch (error) {
          console.error("Error loading existing avatar:", error);
          // エラー時もクリア
          setAvatarBlobUrl(null);
        }
      } else if (selectedAvatarType !== "UserAvatar") {
        // 他のタイプに切り替えたらクリア
        setAvatarBlobUrl(null);
      }
    };

    loadExistingAvatar();
  }, [selectedAvatarType, user.userAvatarPath, avatarPreviewUrl]);

  // クリーンアップ: コンポーネントアンマウント時にオブジェクトURLを解放
  useEffect(() => {
    return () => {
      if (avatarPreviewUrl && avatarPreviewUrl.startsWith("blob:")) {
        URL.revokeObjectURL(avatarPreviewUrl);
      }
    };
  }, [avatarPreviewUrl]);

  const processFile = async (file: File) => {
    // ファイルサイズチェック（5MB制限）
    const maxSize = 5 * 1024 * 1024;
    if (file.size > maxSize) {
      notify.error("ファイルサイズは5MB以下にしてください");
      return;
    }

    // ファイル形式チェック
    const allowedTypes = [
      "image/jpeg",
      "image/jpg",
      "image/png",
      "image/gif",
      "image/webp",
    ];
    if (!allowedTypes.includes(file.type)) {
      notify.error("対応している画像形式: JPEG, PNG, GIF, WebP");
      return;
    }

    // プレビュー表示（URL.createObjectURL を使用）
    try {
      const previewUrl = URL.createObjectURL(file);
      setAvatarPreviewUrl(previewUrl);
    } catch (error) {
      console.error("Preview error:", error);
      notify.error(
        error instanceof Error ? error.message : "画像の読み込みに失敗しました"
      );
      return;
    }

    // ファイルアップロード（Server Action使用）
    setIsLoading(true);
    try {
      // FileをArrayBufferに変換
      const arrayBuffer = await file.arrayBuffer();

      // Server Actionを呼び出し（useRef経由で早期バインドされたものを使用）
      const uploadResult = await uploadActionRef.current({
        fileName: file.name,
        fileType: file.type,
        arrayBuffer: arrayBuffer,
      });

      if (uploadResult.success) {
        setUploadedFileUrl(uploadResult.data?.fileUrl || null);
        notify.success("画像をアップロードしました");
      } else {
        notify.error(uploadResult.message || "アップロードに失敗しました");
        setAvatarPreviewUrl(null);
      }
    } catch (error) {
      console.error("Upload error:", error);
      notify.error(
        error instanceof Error ? error.message : "アップロードに失敗しました"
      );
      setAvatarPreviewUrl(null);
    } finally {
      setIsLoading(false);
    }
  };

  const handleFileUpload = async (
    event: React.ChangeEvent<HTMLInputElement>
  ) => {
    const file = event.target.files?.[0];
    if (!file) {
      return;
    }
    await processFile(file);
    // 同じファイルを再選択できるようにリセット
    event.target.value = "";
  };

  const handleDragOver = (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(true);
  };

  const handleDragLeave = (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(false);
  };

  const handleDrop = async (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(false);

    const file = e.dataTransfer.files?.[0];
    if (!file) {
      return;
    }
    await processFile(file);
  };

  const handleClickUpload = () => {
    fileInputRef.current?.click();
  };

  const handleFileReset = async () => {
    // アップロード済みのファイルを削除
    if (uploadedFileUrl && user.id) {
      const fileName = uploadedFileUrl.split("/").pop();
      if (fileName) {
        setIsLoading(true);
        try {
          const result = await deleteAvatarFile({
            fileName: fileName,
            resourceId: user.id,
          });

          if (result.success) {
            notify.success("アップロード済みファイルを削除しました");
          } else {
            notify.error(result.message || "削除に失敗しました");
          }
        } catch (error) {
          console.error("Delete error:", error);
          notify.error(
            error instanceof Error ? error.message : "削除に失敗しました"
          );
        } finally {
          setIsLoading(false);
        }
      }
    }

    // オブジェクトURLを解放
    if (avatarPreviewUrl && avatarPreviewUrl.startsWith("blob:")) {
      URL.revokeObjectURL(avatarPreviewUrl);
    }
    setUploadedFileUrl(user.identityIconUrl || null);
    setAvatarPreviewUrl(null);
  };

  return (
    <form ref={formRef} onSubmit={handleSubmit} noValidate className="space-y-6 bg-base-100">
      <div className="form-control">
        <label htmlFor="username" className="label">
          <span className="label-text font-semibold text-base-content">
            ユーザー名 <span className="text-error">*</span>
          </span>
        </label>
        <input
          id="username"
          name="username"
          type="text"
          placeholder="ユーザー名を入力"
          className={`input input-bordered ${
            shouldShowError("username") ? "input-error" : ""
          }`}
          defaultValue={user.username || ""}
          onBlur={(e) => validateField("username", e.target.value)}
          disabled={isSubmitting}
          required
        />
        {shouldShowError("username") && (
          <label className="label">
            <span className="label-text-alt text-error">
              {getFieldError("username")}
            </span>
          </label>
        )}
      </div>

      <div className="form-control">
        <label htmlFor="avatarType" className="label">
          <span className="label-text font-semibold text-base-content">アバタータイプ</span>
        </label>
        <select
          id="avatarType"
          className="select select-bordered"
          value={selectedAvatarType}
          onChange={(e) => {
            const newType = e.target.value as "Gravatar" | "UserAvatar" | "AutoGenerated";
            setSelectedAvatarType(newType);
            // アバタータイプ変更時、新規アップロード状態をクリア
            if (newType !== "UserAvatar") {
              setUploadedFileUrl(null);
              setAvatarPreviewUrl(null);
            }
          }}
          disabled={isSubmitting || isLoading}
        >
          <option value="Gravatar">Gravatar（メールアドレス連動）</option>
          <option value="UserAvatar">カスタム画像</option>
          <option value="AutoGenerated">自動生成</option>
        </select>
        <label className="label">
          <span className="label-text-alt text-base-content/60">
            {selectedAvatarType === "Gravatar" && "メールアドレスに紐づいた Gravatar アバターを使用します"}
            {selectedAvatarType === "UserAvatar" && "独自の画像をアップロードして使用します"}
            {selectedAvatarType === "AutoGenerated" && "システムが自動生成したアバターを使用します"}
          </span>
        </label>
      </div>

      {selectedAvatarType === "UserAvatar" && (
        <div className="form-control">
          <label htmlFor="avatarFile" className="label">
            <span className="label-text font-semibold text-base-content">アバター画像</span>
          </label>

          {/* 既存の画像がある場合は表示 */}
          {avatarBlobUrl && !avatarPreviewUrl && (
            <div className="mb-4 p-4 bg-base-200 rounded-lg">
              <div className="flex items-center gap-4">
                <div className="relative group">
                  <button
                    type="button"
                    onClick={() => {
                      // 元画像をダウンロード
                      const fileName = user.userAvatarPath?.split("/").pop();
                      if (fileName) {
                        const downloadUrl = `/api/avatar/download?fileType=Avatar&resourceId=${user.id}&fileName=${encodeURIComponent(fileName)}&useOriginal=true`;
                        const link = document.createElement('a');
                        link.href = downloadUrl;
                        link.download = fileName;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                      }
                    }}
                    className="relative block cursor-pointer"
                    title="クリックして元画像をダウンロード"
                  >
                    <img
                      src={avatarBlobUrl}
                      alt="現在のアバター"
                      className="w-20 h-20 rounded-full object-cover shadow-md ring-2 ring-base-300 transition-opacity group-hover:opacity-75"
                    />
                    {/* ダウンロードアイコン */}
                    <div className="absolute inset-0 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity">
                      <svg
                        xmlns="http://www.w3.org/2000/svg"
                        className="h-8 w-8 text-white drop-shadow-lg"
                        fill="none"
                        viewBox="0 0 24 24"
                        stroke="currentColor"
                      >
                        <path
                          strokeLinecap="round"
                          strokeLinejoin="round"
                          strokeWidth={2}
                          d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"
                        />
                      </svg>
                    </div>
                  </button>
                </div>
                <div className="flex-1">
                  <p className="text-sm font-medium text-base-content">現在のアバター画像</p>
                  <p className="text-xs text-base-content/60 mt-1">
                    クリックして元画像をダウンロード
                    <br />
                    新しい画像をアップロードすると置き換わります
                  </p>
                </div>
              </div>
            </div>
          )}

          {/* ドラッグ&ドロップエリア */}
          <div
            onDragOver={handleDragOver}
            onDragLeave={handleDragLeave}
            onDrop={handleDrop}
            className={`relative border-2 border-dashed rounded-lg p-8 text-center transition-all
              ${isDragging
                ? "border-primary bg-primary/10 scale-[1.02]"
                : "border-base-300 hover:border-primary/50 hover:bg-base-200/50"
              }
              ${isLoading ? "opacity-50 cursor-not-allowed" : ""}
            `}
          >
            <input
              ref={fileInputRef}
              id="avatarFile"
              type="file"
              accept="image/jpeg,image/jpg,image/png,image/gif,image/webp"
              className="hidden"
              onChange={handleFileUpload}
              disabled={isSubmitting || isLoading}
            />

            {avatarPreviewUrl ? (
              <div className="flex flex-col items-center gap-4">
                <div className="relative">
                  <img
                    src={avatarPreviewUrl}
                    alt="プレビュー"
                    className="w-32 h-32 rounded-full object-cover shadow-lg ring-4 ring-primary/20"
                  />
                  {isLoading && (
                    <div className="absolute inset-0 flex items-center justify-center bg-base-100/50 rounded-full">
                      <span className="loading loading-spinner loading-lg text-primary"></span>
                    </div>
                  )}
                </div>
                <div className="space-y-2">
                  {uploadedFileUrl ? (
                    <div className="flex items-center gap-2 justify-center">
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-success" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                      </svg>
                      <p className="text-sm font-medium text-base-content">
                        新しい画像をアップロード完了
                      </p>
                    </div>
                  ) : (
                    <div className="flex items-center gap-2 justify-center">
                      <span className="loading loading-spinner loading-sm"></span>
                      <p className="text-sm font-medium text-base-content">
                        アップロード中...
                      </p>
                    </div>
                  )}
                  <button
                    type="button"
                    onClick={(e) => {
                      e.stopPropagation();
                      handleFileReset();
                    }}
                    className="btn btn-sm btn-outline btn-error"
                    disabled={isSubmitting || isLoading}
                  >
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                    </svg>
                    削除して再選択
                  </button>
                </div>
              </div>
            ) : (
              <div
                className="flex flex-col items-center gap-4 cursor-pointer"
                onClick={handleClickUpload}
              >
                <div className={`p-4 rounded-full transition-colors ${isDragging ? "bg-primary/20" : "bg-base-200"}`}>
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    className={`h-12 w-12 transition-colors ${isDragging ? "text-primary" : "text-base-content/40"}`}
                    fill="none"
                    viewBox="0 0 24 24"
                    stroke="currentColor"
                  >
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      strokeWidth={2}
                      d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"
                    />
                  </svg>
                </div>
                <div className="space-y-1">
                  <p className="text-base font-semibold text-base-content">
                    {isDragging ? "ここにドロップ" : user.identityIconUrl ? "新しい画像をアップロード" : "画像をドラッグ&ドロップ"}
                  </p>
                  <p className="text-sm text-base-content/60">
                    または<span className="text-primary font-medium">クリックして選択</span>
                  </p>
                </div>
                <div className="text-xs text-base-content/50 space-y-1">
                  <p>対応形式: JPEG, PNG, GIF, WebP</p>
                  <p>最大サイズ: 5MB</p>
                </div>
              </div>
            )}
          </div>
        </div>
      )}

      <div className="flex justify-end mt-6">
        <button
          type="submit"
          className="btn btn-primary"
          disabled={isSubmitting}
        >
          {isSubmitting ? (
            <>
              <span className="loading loading-spinner loading-sm"></span>
              更新中...
            </>
          ) : (
            "基本情報を更新"
          )}
        </button>
      </div>
    </form>
  );
}
